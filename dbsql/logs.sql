/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50624
Source Host           : localhost:3306
Source Database       : ssm

Target Server Type    : MYSQL
Target Server Version : 50624
File Encoding         : 65001

Date: 2017-02-17 17:58:36
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for logs
-- ----------------------------
DROP TABLE IF EXISTS `logs`;
CREATE TABLE `logs` (
  `log_id` varchar(15) CHARACTER SET utf8 COLLATE utf8_unicode_ci NOT NULL,
  `log_title` varchar(100) DEFAULT NULL,
  `log_summary` varchar(100) DEFAULT NULL,
  `log_content` varchar(10000) DEFAULT NULL,
  `log_created` datetime DEFAULT NULL,
  `log_update` datetime DEFAULT NULL,
  PRIMARY KEY (`log_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of logs
-- ----------------------------
INSERT INTO `logs` VALUES ('1701131348', 'crainnogao博客前言', '前言', '##### 这是crainnogao成立以来第一篇正式的日志 \n&emsp;&emsp;差不多两个多月前我开始了解idea,正式接触idea,都说这个比eclipse强大,的确用过才知道。但是对于我而言，刚开始理解是有点困难，难的不是idea这个软件的使用，而是还是java的一些配置文件，maven什么的。  \n\n&emsp;&emsp;这些内容我本身理解起来就有些障碍，但是结果这两个月的摸索也算学到了不少，我的这个博客还没有发布出去，因为服务器真心贵啊，买不起啊啊啊啊啊。。。  \n\n&emsp;&emsp;现在目前呢可以先这样，我先还是在本地上运行吧，以后有机会再放到服务器上。这个博客本身还有很多缺陷，不过大体上可以简单的以一种正常网站的形式运行了，以后慢慢改善吧~~~  \n\n&emsp;&emsp;不过我是真心觉得这个markdown不怎么好用，难道就没有别的方法嘛嘛嘛。。。。\n&emsp;&emsp;', '2017-01-13 13:48:47', '2017-01-13 13:48:47');
INSERT INTO `logs` VALUES ('1701191150', '2016年总结', '年度总结', '##### &emsp;今天是2016年我在图众意义上工作的最后一天\n##### &emsp;(明天大扫除年夜饭,大家都很忙,估计也不怎么工作了吧~)  \n##### &emsp;2016年4.5号是我进公司的第一天,也是人生中的第一天上班,那天很开心。至今我工作了，九个半月。这九个多月我完成了一个身份的转型，从学生生活到工作生活的转变，这其实对我来说还是比较困难的，学生的角色我一当就是16年，这是一项伟大的事业，没有之前的16年的成长就没有今天的我，原本我以为我还可以再多做几年学生的，可是梦想破灭了，但是也算是一种尝试，我不后悔尝试，也不奢望再来一次，只看日后道路如何了吧。\n##### &emsp;说说我的工作吧:\n##### &emsp;四年都是主修计算机专业，但是学校课堂里针对java开发方面的知识仅仅局限于java基础，并没有学的很深入。入职初期，我最先学习的是:虽然大学四年都是主修计算机专业，但是学校课堂里针对java开发方面的知识仅仅局限于java基础，并没有学的很深入。入职初期，我最先学习的是:  \n(1)**ssi框架**，我们公司用的就是这个ssi框架(即spring+srpingmvc+ibatise)。spring是企业级 Java 应用程序开发框架，Springmvc提供了模型-视图-控制的体系结构。iBATIS(持久层框架)是把实体类和sql语句之间建立了映射关系，这种策略可以允许开发人员自己来写合适的sql语句。然而针对持久层iBatise，现在用的比较多的就是mybatise持久层框架，这算是对ibatise的一种升级。我们公司的项目也应该与时俱进，以后有时间的话可以考虑采用mybatise来代替ibatise。之后学习的是:  \n(2)**maven**的相关知识，我们公司的项目建立的就是maven项目。其实对于maven的学习我也是理解能力有限，但也是一直都在学习中。下面是我对maven的一些简单的概念上的理解:\n&emsp;Apache Maven 是一套软件工程管理和整合工具。Maven 工程结构和内容被定义在pom.xml。POM 包含了关于工程和各种配置细节的信息，Maven 使用这些信息构建工程。POM 也包含了目标和插件。当执行一个任务或者目标时，Maven 会查找当前目录下的 POM，从其中读取所需要的配置信息，然后执行目标。每个工程应该只有一个 POM 文件。另一个比较重要的就是maven仓库。Maven 本地仓库保存的是我们工程的所有依赖jar包。当运行一次 Maven 构建，Maven 会自动下载所有依赖的 jar 文件到本地仓库中。这样避免了每次构建时都引用存放在远程机器上的依赖文件。maven还有中央仓库，是由 Maven 社区提供的仓库，其中包含了大量常用的库。\n上面两个知识算是java开发比较基础和重要的两个内容，也是我比较难以理解的两点，我也一直都在积累学习。  \n(3)第三点就说说我在公司项目中负责的工作内容。入职以后我一直都在参与爱发货的研发和版本迭代。参与过的产品模块有货源、专线、订单、用户还有56tc的用户认证等一些内容。刚刚参与项目的时候，我什么都不会，说的简单点就是不知道代码该写在哪里，幸好有同事帮我，我一直都记得是韩亚飞同事教我如何使用springmvc，说的简单点就是如何将数据库的数据经过处理拿到页面上，因为之前在学校里学过dao、servlet和controller层与层的关系，所以经过同事的讲解学的也比较快。后期的学习中也遇到了比较多的问题，在我自己的努力下还有同事的帮助下也都得到了解决，尤其是金磊同事教会了我很多。\n##### &emsp;其实不懂的地方还真的很多，做这个博客也是为了把学到的东西自己运用一遍。', '2017-01-19 11:50:33', '2017-01-19 11:50:33');
INSERT INTO `logs` VALUES ('1702061404', 'mybatise学习笔记', 'mybatise', '##### mybatis就是一个封装来jdbc的持久层框架，它和hibernate都属于ORM框架，但是具体的说，hibernate是一个完全的orm框架，而mybatis是一个不完全的orm框架。\n\n##### Mybatis让程序员只关注sql本身，而不需要去关注如连接的创建、statement的创建等操作。\n\n##### Mybatis会将输入参数、输出结果进行映射。', '2017-02-06 14:04:44', '2017-02-06 14:04:45');
INSERT INTO `logs` VALUES ('1702151722', 'Object常用公用方法', 'object类', '##### **①toString方法**\n	String toString()\n##### 该方法用得比较多，一般子类都有覆盖。\n##### **②equals方法**\n	boolean equals(Object obj)\n##### 该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。\n##### **③hashCode方法**\n	int hashCode()\n##### 该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。\n\n##### 1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.ha一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。\n##### ==:表示判断两个字符串在内存中首地址的地址是否相同\n##### equals:比较存储在两个字符串中对象中的内容是否相同\n##### 如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。\n##### **④wait方法**\n	void wait()\n##### wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。\n\n##### 调用该方法后当前线程进入睡眠状态，直到以下事件发生。\n\n##### （1）其他线程调用了该对象的notify方法。\n\n##### （2）其他线程调用了该对象的notifyAll方法。\n\n##### （3）其他线程调用了interrupt中断该线程。\n\n##### （4）时间间隔到了。\n\n##### 此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。\n##### **⑤notify方法**\n	void notify()\n##### 该方法唤醒在该对象上等待的某个线程。\n##### **⑥notifyAll方法**\n	void notifyAll()\n##### 该方法唤醒在该对象上等待的所有线程。\n##### **⑦clone方法**\n	protected Object clone()\n##### 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。\n##### 主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。\n##### **⑧getClass方法**\n	Class<?> getClass()\n##### final方法，获得运行时类型。', '2017-02-15 17:22:36', '2017-02-15 17:22:36');
INSERT INTO `logs` VALUES ('1702161433', 'Java的四种引用，强弱软虚，用到的场景', 'java的四种引用', '##### **1、强引用**\n##### 最普遍的一种引用,不会被垃圾回收器回收\n##### 当内存不足时,只会抛出OutOfMemeroyError异常,使程序异常终止。如果不使用时，通过下面的方式弱化:\n	Object o = new Object();  //强引用\n	o = null;                 //弱化引用,利于回收\n##### 方法内调用强引用，引用保存在栈内，引用的内容保存在堆内，执行完后，引用退出栈，引用的内容不存在，此时，强引用Object会被回收。\n##### **使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。**\n##### **2、软引用**\n#####  如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。\n	String str=new String(\'abc\');  // 强引用  \n	SoftReference<String> softRef=new SoftReference<String>(str); // 软引用    \n##### 当内存不足时，等价于：\n	If(JVM.内存不足()) {  \n		str = null;  // 转换为软引用  \n		System.gc(); // 垃圾回收器进行回收  \n	}  \n##### **引用场景**：软引用可用来实现内存敏感的高速缓存。例如：浏览器的后退操作。\n##### （1）如果一个网页在浏览结束时就进行内容的回收，则按后退查看前面浏览过的页面时，需要重新构建\n##### （2）如果将浏览过的网页存储到内存中会造成内存的大量浪费，甚至会造成内存溢出。这时候就可以使用软引用。\n	Browser prev = new Browser();  // 获取页面进行浏览\n	SoftReference sr = new SoftReference(prev); // 浏览完毕后置为软引用    \n	if(sr.get()!=null){ \n		rev = (Browser) sr.get(); // 还没有被回收器回收，直接获取\n	}else{\n		prev = new Browser();  // 由于内存吃紧，所以对软引用的对象回收了\n		sr = new SoftReference(prev);       // 重新构建\n	}\n##### 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n##### **弱引用**\n##### 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。\n##### 当垃圾回收器进行扫描回收时等价于：\n	str=null;\n	System.gc();\n##### 应用场景:\n#####  如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。当你想引用一个对象，但是这个对象有自己的生命周期，你不想介入这个对象的生命周期，这时候你就是用弱引用。\n##### 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n##### **虚引用**\n##### “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n##### 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n##### **总结**\n##### Java4种引用的级别由高到低依次为：\n	强引用  >  软引用  >  弱引用  >  虚引用\n关系图见：[http://blog.csdn.net/mazhimazh/article/details/19752475](http://blog.csdn.net/mazhimazh/article/details/19752475)', '2017-02-16 14:33:38', '2017-02-16 14:33:38');
INSERT INTO `logs` VALUES ('1702161501', 'java中HashCode的作用', 'HashCode', '##### 1、`hashCode`的存在主要是用于查找的快捷性，如`Hashtable，HashMap`等，`hashCode`是用来在散列存储结构中确定对象的存储地址的；\n##### 2、如果两个对象相同，就是适用于```equals(Java.lang.Object)``` 方法，那么这两个对象的hashCode一定要相同；\n##### 3、如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；\n##### 4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构4、两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。\n	public class HashTest {  \n		private int i;  \n		public int getI() {  \n			return i;  \n		}  \n		public void setI(int i) {  \n			this.i = i;  \n		}  \n		public boolean equals(Object object) {  \n			if (object == null) {  \n				return false;  \n			}  \n			if (object == this) {  \n				return true;  \n			}  \n			if (!(object instanceof HashTest)) {  \n				return false;  \n			}  \n			HashTest other = (HashTest) object;  \n			if (other.getI() == this.getI()) {  \n				return true;  \n			}  \n			return false;  \n		}</strong></span>  \n		public int hashCode() {  \n			return i % 10;  \n		}  \n		public final static void main(String[] args) {  \n			HashTest a = new HashTest();  \n			HashTest b = new HashTest();  \n			a.setI(1);  \n			b.setI(1);  \n			Set<HashTest> set = new HashSet<HashTest>();  \n			set.add(a);  \n			set.add(b);  \n			System.out.println(a.hashCode() == b.hashCode());  \n			System.out.println(a.equals(b));  \n			System.out.println(set);  \n		}  \n	} \n##### 结果:\n	true  \n	true  \n	[com.ubs.sae.test.HashTest@1]  \n##### 若没有重写equals方法，那么就会调用object默认的equals方法，是比较两个对象的引用是不是相同，显示这是两个不同的对象，两个对象的引用肯定是不定的。这里我们将生成的对象放到了HashSet中，而HashSet中只能够存放唯一的对象，也就是相同的（适用于equals方法）的对象只会存放一个，但是这里实际上是两个对象a,b都被放到了HashSet中，这样HashSet就失去了他本身的意义了。\n##### Java对于eqauls方法和hashCode方法是这样规定的： \n##### 1、如果两个对象相等，那么它们的hashCode值一定要相等； \n##### 2、如果两个对象的hashCode相等，它们并不一定相等。', '2017-02-16 15:01:05', '2017-02-16 16:53:13');
INSERT INTO `logs` VALUES ('1702161542', 'String、StringBuffer与StringBuilder的区别', 'String StringBuffer StringBuilder', '##### **1、String**\n##### String：字符串常量，字符串长度不可变。Java中String是immutable（不可变）的。\n##### **2、StringBuffer**\n##### StringBuffer：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用StringBuffer，如果想转成String类型，可以调用StringBuffer的toString()方法。\n##### StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。\n##### **3、StringBuilder**\n##### StringBuilder：字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。\n##### java.lang.StringBuilder是一个可变的字符序列，是JDK5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。\n##### **4、三者区别**\n##### String 类型和StringBuffer的主要性能区别：\n##### String是不可变的对象, 因此在每次对String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。\n##### 使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。\n##### 在某些特别情况下， String 对象的字符串拼接其实是被 Java Compiler 编译成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，例如：\n	String s1 = “This is only a” + “ simple” + “ test”;  \n	StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);  \n##### 生成 String s1对象的速度并不比 StringBuffer慢。其实在Java Compiler里，自动做了如下转换：\n##### Java Compiler直接把上述第一条语句编译为：\n	String s1 = “This is only a simple test”;  \n##### 所以速度很快。但要注意的是，如果拼接的字符串来自另外的String对象的话，Java Compiler就不会自动转换了，速度也就没那么快了，例如：\n	String s2 = “This is only a”;  \n	String s3 = “ simple”;  \n	String s4 = “ test”;  \n	String s1 = s2 + s3 + s4;  \n##### 这时候，Java Compiler会规规矩矩的按照原来的方式去做，String的concatenation（即+）操作利用了StringBuilder（或StringBuffer）的append方法实现，此时，对于上述情况，若s2，s3，s4采用String定义，拼接时需要额外创建一个StringBuffer（或StringBuilder），之后将StringBuffer转换为String；若采用StringBuffer（或StringBuilder），则不需额外创建StringBuffer。\n##### **使用策略**\n##### （1）基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。\n##### （2）不要使用String类的+来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则。例如：\n	String result = \'\';  \n	for (String s : hugeArray) {  \n		result = result + s;  \n	}    \n	// 使用StringBuilder  \n	StringBuilder sb = new StringBuilder();  \n	for (String s : hugeArray) {  \n		sb.append(s);  \n	}  \n	String result = sb.toString();  \n##### 当出现上面的情况时，显然我们要采用第二种方法，因为第一种方法，每次循环都会创建一个String result用于保存结果，除此之外二者基本相同（对于jdk1.5及之后版本）。\n##### （3）为了获得更好的性能，在构造 StringBuffer 或 StringBuilder 时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过 16 个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能。\n##### （4）StringBuilder一般使用在方法内部来完成类似+功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer主要用在全局变量中。\n##### （5）相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用StringBuilder；否则还是用StringBuffer。', '2017-02-16 15:42:05', '2017-02-16 15:42:05');
INSERT INTO `logs` VALUES ('1702171136', 'HashMap的数据结构及put数据工作原理', 'HashMap', '##### HashMap数据结构：数组+单链表。也就是数组（散列桶）中的每一个元素都是链表。是非线程安全的。\n##### 1. HashMap保证Key唯一是通过哈希表来管理的，即散列表，哈希算法可以快速的存储数据。\n##### 2.put数据是，首先调用hashCode方法，得到一个哈希码，\n##### **hashCode相等，equals不一定为true；**\n##### **hashCode不相等，equals一定为false。**\n##### 当hashCode相等时，会发生碰撞，此时需要调用equals方法进行比较；即只有发生碰撞的时候才会用到equals方法。\n##### **总结**\n##### **1.HashMap通过Key的hashCode方法实现快速存取；**\n##### **2.当发生碰撞时，HashMap通过单链表来解决，新元素加入表头，用next指向下一元素。单链表在java中的实现就是对象的引用（复合）。**\n[![HashMap数据结构图](D:\\idea2016\\crainnogao\\src\\main\\webapp\\WEB-INF\\statics\\images\\HashMap DS.png \"HashMap数据结构图\")](D:\\idea2016\\crainnogao\\src\\main\\webapp\\WEB-INF\\statics\\images\\HashMap DS.png \"HashMap数据结构图\")', '2017-02-17 11:36:54', '2017-02-17 11:37:50');
INSERT INTO `logs` VALUES ('1702171405', 'HashMap性能影响', 'HashMap', '##### **影响HashMap性能的两个参数:**初始容量和加载因子\n##### 初始容量:(默认16)容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。\n##### 加载因子:(默认0.75)是哈希表在其容量自动增加之前可以达到多满的一种尺度。\n##### 当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用 rehash 方法将容量翻倍。\n##### **如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？**\n##### HashMap的工作原理:默认的负载因子大小为0.75，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。\n##### **你了解重新调整HashMap大小存在什么问题吗？**\n##### 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。\n###### 这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？', '2017-02-17 14:05:28', '2017-02-17 14:05:28');
